<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[VUE官方教程随笔]]></title>
      <url>%2F2017%2F03%2F23%2FVUE%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E9%9A%8F%E7%AC%94%2F</url>
      <content type="text"><![CDATA[好吧~酱酱本来在看es6的promise，偶然发现了VUE.JS,一不小心看了下大概，发现还挺有趣。所以索性就先把promise撂在一边，去官网学习下vue.。当然我也不确定这个会更新到什么时候，哈哈。 vue的安装兼容性vue.js不支持ie8及其以下版本，支持所有兼容es5的浏览器。 npm$ npm install vue 命令行工具vue.js 提供一个官方的命令行工具，可以快速搭建单页面应用，我们先用他来测试下。 # 全局安装 vue-cli $ npm install --g vue-cli # 创建一个基于webpack模板的项目 $ vue init webpack job # 安装依赖 $ cd job $ npm install $npm run dev 上面这个就是我初步测试的一个项目,当然这个是没有路由的，init的时候会有选项，可以产生更多的功能以及模块 vue.js的初步体验hello world&lt;div id=&quot;app&quot;&gt; {{ message }} &lt;/div&gt; var app = new Vue({ el: &apos;#app&apos;, data: { message: &apos;Hello Vue!&apos; } }) vue提供了数据和dom的绑定，当代码更改，页面就会更新。有点类似于webpack的热加载和angularjs。 生命周期机智的我从官网上偷来了这个图，看起来灰常长~长~长~~~所以，我就不解释了，很·清晰· vue.js 模板语法之后我就使用官方的title了，毕竟只是随笔，摘抄总结些知识点 语法 文本 mustache ： &lt;span&gt;Message: &lt;/span&gt; 如果为一次性插入，则为 &lt;span v-once&gt;This will never change: &lt;/span&gt; 纯html： &lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt; 文本 v-text=“msg” 等价于 绑定属性： v-bind &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; js表达式： NaN &lt;div v-bind:id=&quot; &#39;list&#39; +id &quot;&gt;&lt;/div&gt; 绑定事件 v-on &lt;a v-on:click=&quot;event&quot;&gt;&lt;/a&gt; 过滤器 1.过滤器函数总是接受表达式的第一个值作为第一个参数，表达式的参数则从第二个开始。 可以添加多个表达式。 2.过滤器可以用到两个地方 mustache 插值以及v-bind 表达式 {{ item.label | filter(''123') }} filters:{ filter(val,arg1){ if(!val) return &apos;&apos;; val=val.toString(); return val.charAt(0).toUpperCase()+val.slice(1); } } arg1 = 123 缩写 v-on &lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; v-bind &lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; 计算属性计算属性不需要再data里声明，依赖于data里面的数据，并且自动更新。计算属性只有在它的相关依赖发生改变时才会重新求值 &lt;h4&gt;{{ computedMsg }}&lt;/h4&gt; computed:{ computedMsg(){ return this.newItem.split(&apos;&apos;).reverse().join(&apos;&apos;); } } watch监听items的值，当发生变化，则调用handler函数。 watch : { items : { handler(oldVal, newVal){ Store.save(newVal); }, deep : true } }, CLass与Style的绑定绑定html classclass v-bind&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt; class ’active‘ 的更新取决于 isActive的 true or false 多个class用 逗号 , 分隔 计算属性的应用： &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; data: { isActive: true, error: null }, computed: { classObject: function () { return { active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;, } } } 多个class，数组形式表现 &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt; data: { activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos; } 渲染为: &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; style v-bind&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt; data: { activeColor: &apos;red&apos;, fontSize: 30 } OR 直接绑定 &lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; data: { styleObject: { color: &apos;red&apos;, fontSize: &apos;13px&apos; } } 条件渲染 v-if条件判断 &lt;h1 v-if=&quot;ok&quot;&gt;YES&lt;/h1&gt; &lt;h1 v-else&gt;NO&lt;/h1&gt; 切换多个元素，可以用 template &lt;template v-if=&quot;ok&quot;&gt; &lt;span&gt;s1&lt;/span&gt; &lt;span&gt;s2&lt;/span&gt; &lt;/template&gt; if = v-ifelse if = v-else-ifelse = v-else key管理可复用元素如果用条件语句切换同一个元素的时候，改元素将不会替换掉，只会替换掉相对应的属性。如果需要替换，需要添加key &lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt; &lt;/template&gt; v-show v-show 不支持 template语法 v-show css的属性 display的切换 v-if涉及到元素的创建以及销毁 列表渲染v-foritem in items 语法渲染 也可以用 item of items &lt;ul id=&quot;example-2&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; {{ parentMessage }} - {{ index }} - {{ item.message }} &lt;/li&gt; &lt;/ul&gt; v-for 支持template标签 v-for 支持遍历对象参数分别为 value key index &lt;p v-for=&quot;(val, key , index) in object&quot;&gt;{{ index+" : "+key+" - "+val }}&lt;/p&gt; v-for支持取整数&lt;span v-for=&quot;n in 10&quot;&gt;&lt;/span&gt; 数组变更检测 以下两种情况，vue不能检测变动而的数组1.当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue2.当你修改数组的长度时，例如： vm.items.length = newLength解决办法： 1： Vue.set(example1.items, indexOfItem, newValue) example1.items.splice(indexOfItem, 1, newValue) 2： example1.items.splice(newLength) 时间处理器监听事件v-on监听也可以直接用vue的实例调用。 var vm = new Vue({ method:{ hello(){ } } })； vm.hello(); 表单控件绑定v-modelv-model 可以绑定文本值checkbox：&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;radio： &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;select： &lt;select v-model=&quot;selected&quot;&gt;v-model绑定的是标签的value还可以更改绑定耳朵value。 v-bind&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot; &gt;&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;过滤收尾空格： &lt;input v-model.trim=&quot;msg&quot;&gt; 组件 component注册命名尽量遵守W3C规则(小写并包含一个短杠) #注册全局组件 Vue.component(&apos;&apos;my-componetn&apos;,{ template: &apos;&lt;div&gt;hello&lt;/div&gt;&apos; }); #局部注册 new Vue({ components:{ &apos;my-btn&apos;: { data(){ return { id: 10 } }, template: &apos;&lt;button v-on:click=&quot;id++&quot;&gt;{{ id }}&lt;/button&gt;&apos; } } }) 组件传递数据prop子组件用 props 声明所需的字符串 Vue.component(&apos;child&apos;, { // 声明 props props: [&apos;message&apos;], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像 “this.message” 这样使用 template: &apos;&lt;span&gt;{{ message }}&lt;/span&gt;&apos; }) #传值 &lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; Note: HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名 Vue.component(&apos;child&apos;, { // camelCase in JavaScript props: [&apos;myMessage&apos;], template: &apos;&lt;span&gt;{{ myMessage }}&lt;/span&gt;&apos; }) &lt;!-- kebab-case in HTML --&gt; &lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt; 如果需要动态传值，绑定父子关系 单项绑定，则用 v-bind:my-mysssage 。 子组件不应该在内部改变prop。 ① ： 定义一个局部变量，并用 prop 的值初始化它： props: [&apos;initialCounter&apos;], data: function () { return { counter: this.initialCounter } } ② ： 定义一个计算属性，处理 prop 的值并返回。 props: [&apos;size&apos;], computed: { normalizedSize: function () { return this.size.trim().toLowerCase() } } Tip: 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 自定义事件 vue的事件接口 $on(eventName) 监听事件 $emit(eventName) 触发事件 &lt;div id=&quot;counter-event-example&quot;&gt; &lt;p&gt;{{ total }}&lt;/p&gt; &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt; &lt;/div&gt; Vue.component(&apos;button-counter&apos;, { template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;{{ counter }}&lt;/button&gt;&apos;, data: function () { return { counter: 0 } }, methods: { increment: function () { this.counter += 1 this.$emit(&apos;increment&apos;) } }, }) new Vue({ el: &apos;#counter-event-example&apos;, data: { total: 0 }, methods: { incrementTotal: function () { this.total += 1 } } }) 非父子组件间通信 如果简单情况下，可以使用一个空的Vue实例作为中央事件总线 var bus = new Vue() // 触发组件 A 中的事件 bus.$emit(&apos;id-selected&apos;, 1) // 在组件 B 创建的钩子中监听事件 bus.$on(&apos;id-selected&apos;, function (id) { // ... }) 使用slot分发内容单个slot除非子组件模板包含至少一个 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。 假定 my-component 组件有下面模板： &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt; &lt;/div&gt; 父组件模版： &lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt; &lt;/div&gt; 渲染结果： &lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 具名slot 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。 例如，假定我们有一个 app-layout 组件，它的模板为： &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; 父组件模版： &lt;app-layout&gt; &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt; &lt;/app-layout&gt; 渲染结果为： &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 动态组件is 特性。多个组件使用同一个挂载点，并且动态切换 var vm = new Vue({ el: &apos;#example&apos;, data: { currentView: &apos;home&apos; }, components: { home: { /* ... */ }, posts: { /* ... */ }, archive: { /* ... */ } } }) &lt;component v-bind:is=&quot;currentView&quot;&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt; &lt;/component&gt; keep-alive动态切换组件的状态缓存保留 &lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt; &lt;/keep-alive&gt; ####编写可复用组件 在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。 Vue 组件的 API 来自三部分 - props, events 和 slots ： Props 允许外部环境传递数据给组件 Events 允许组件触发外部环境的副作用 Slots 允许外部环境将额外的内容组合在组件中。使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁： &lt;my-component :foo=&quot;baz&quot; :bar=&quot;qux&quot; @event-a=&quot;doThis&quot; @event-b=&quot;doThat&quot; &gt; &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt; &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt; &lt;/my-component&gt; 好了，经过艰苦卓绝的探索实践过程，Vue官方教程的基础篇完成了。其实组件还有一些杂项，不过大多属于心得方面的吧，以后开发可以参考。经过这次Vue的探索之旅，真实良心官方教程啊。外国的坑爹教程，目不忍视。不管怎么样，基础里面还有一些涉及到进阶篇的内容。之后会补充上。好了，起飞！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[来谈谈Promise]]></title>
      <url>%2F2017%2F03%2F17%2F%E6%9D%A5%E8%B0%88%E8%B0%88Promise%2F</url>
      <content type="text"><![CDATA[Promise——异步编程解决方案酱酱这段时间又学习了下nodejs，发现了promise这个神奇的东东。看了网上的几篇博文，各种思想在脑中疯狂的对战，乱的很。/(ㄒoㄒ)/~~实在没办法，希望一边写一边理解吧-。- Promise的登场promise是什么呢？因为ES6发布了，promise被列为正式规范，主流浏览器对ES6也是极大的支持，所以我们先在chrome浏览器中看下这个宝贝啥东东。promise对象是一个构造函数，拥有all、race、reject以及resolve方法。new的新对象有catch和then方法。 promise的状态promise三种状态：未完成(pending),已完成(fulfilled),失败(rejected).状态之前之间不可逆转。 promise的用法var promise = new Promise(function(resolve, reject) { if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); promise添加了一个函数作为参数——resolve,reject。resolve函数可以将promise状态由pending-&gt;fulfilled，异步操作成功时调用。reject函数可以将promise状态由pending-&gt;rejected，异步操作失败时调用。 promise.then(resolve,reject){ } promise的then方法接收resolve和reject回调函数，分别为成功和失败。reject函数是可选的。promise可以调用多个then方法，顺序执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[史诗级逆转——无敌巴萨]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%8F%B2%E8%AF%97%E7%BA%A7%E9%80%86%E8%BD%AC%E2%80%94%E2%80%94%E6%97%A0%E6%95%8C%E5%B7%B4%E8%90%A8%2F</url>
      <content type="text"><![CDATA[欧冠-奇迹！95分钟绝杀 巴萨6-1巴黎惊天逆转北京时间3月9日03:45(西班牙当地时间8日20:45)，2016/17赛季欧冠1/8决赛次回合一场焦点战在诺坎普球场展开争夺，巴塞罗那主场6比1取胜巴黎圣日耳曼，苏亚雷斯和梅西进球，库尔扎瓦乌龙，但卡瓦尼打入关键客场进球，内马尔梅开二度，塞尔吉-罗伯托第95分钟绝杀。巴萨总分6比5涉险晋级。巴萨也成为首支在欧战首回合4球落后下成功翻盘的球队。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用命令集合]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88%2F</url>
      <content type="text"><![CDATA[新建一篇博客1hexo new post "article title" 文章编辑好之后，运行生成、部署命令：1hexo g // 生成 1hexo d // 部署 执行下面的命令，相当于上面两条命令的效果1hexo d -g #在部署前先生成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>%2F2017%2F03%2F07%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
      <content type="text"><![CDATA[这是我的第一个博客文章，新的开始。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
